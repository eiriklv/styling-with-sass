<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Sizing things â€• Styling with Sass</title>
    <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
    <link rel="stylesheet" type="text/css" href="//cloud.typography.com/6225112/658766/css/fonts.css" />
    <link rel="stylesheet" href="stylesheets/manifest.css">
  </head>
  <body>
    <section class="chapter-section">
      <h1>
        Sizing things
      </h1>
      <article>
        <p>
          Sizing text and blocks, although distinct challenges with their own particulars, in order for correctness to be retained and for things to stay as easy as possible to use, a mechanism is necessary for implementing a grid. That mechanism should be unobtrusive as possible, rather than something to be learned or turn into a reference one needs to constantly look at. Therefore, the API surface should be very small.
        </p>
        <p>
          A grid's main function is to define the steps that any element can grow or be positioned into. In saying the word "grid", it immediately comes to mind the idea of columns, but a column is really just a helper for understanding the fact that you are in reality putting things in a map.
        </p>
        <p>
          Think of a chessboard. The grid is composed by squares, and you can only move one square, or many, or half (that's unlike chess, generally not recommended, but technically within proportion), but never by 77% of a unit, or another non-proportional measure.
        </p>
        <p>
          Creativity wants freedom. And these constraints can come across as being opposed to that, but in fact they're there to assist you with keeping proportion, a key element of aesthetics, and thus, good design. In short: using a grid helps making things look right on the screen.
        </p>
      </article>
      <article>
        <p>
          Let's start by addressing the problem of sizing units, and a common misconception about them.
        </p>
        <p>
          Much has been said about `px`, `ems`, `rems`. In short, `px` being considered wrong, `ems` are ok, and `rems` are "easy ems". I'll propose something else entirely: when you work with scales, the unit does not matter, not even a little bit.
        </p>
        <p>
          The `px` stigma, to the best of my knowledge, comes from the old days os the web when IE had a bug in which text wouldn't scale up when the page was zoomed (Ctrl/CMD plus). Someone then said pixels were a bad idea and a lot was lost in the message.
        </p>
        <p>
          The proposed solution to the problem was to use ems instead, but with ems comes great power, and with great power comes great responsibility. ems are a proportional, tool-like measure which can *very* easily create a hell of a cascading mess of font sizings if not used mindfully.
        </p>
        <p>
          For instance, it's not rare finding `font-size` directives applied to containers (often a mistake). Small containers that have one font size used by all its child nodes would be fine, but think of something like this:
        </p>
        <pre><code>
        &lt;pre&gt;&lt;code&gt;&lt;section&gt;
      &lt;h1&gt;A heading&lt;/h1&gt;
      &lt;p&gt;
        Lorem ipsum something.
      &lt;/p&gt;
      &lt;blockquote&gt;
        Rah rah rah
      &lt;/blockquote&gt;
      &lt;aside&gt;
        &lt;p&gt;Yeah but&#x2026;&lt;/p&gt;
      &lt;/aside&gt;
    &lt;/section&gt;</code></pre>
        <p>
          In setting the section's font size to something like `1.6em`, every child node gets its base size reset to that value. Meaning: If the font-size of `h1` is set to `1em`, nothing changes, because `1em` means "100% of the parent's font-size", for all intents and purposes.
        </p>
        <p>
          But we want the heading size to be "slightly bigger" than the rest, no? So we go:
        </p>
        <pre><code>h1 {
  font-size: 1.3em;
}</code></pre>
        <p>
          So ok, but perhaps blockquote should be a bit bigger too, so we go:
        </p>
        <pre><code>blockquote {
  font-size: 1.1em;
}</code></pre>
        <p>
          And aside should be a bit smaller, right? That makes sense:
        </p>
        <pre><code>aside {
  font-size: .8em;
}</code></pre>
        <p>
          (In short, you're actually saying "130%", "110%", and "80%" of the container's font size. For clarity sake, *you may as well just use percentages*, since those take no decyphering)
        </p>
        <p>
          Now picture what happens in a web app scenario with multiple nested components. Granted, this is ems in misuse, and this doesn't mean ems are a bad idea. But they carry tooling with them, so they're ideal for on-the-spot proportional measures, which don't fit the vision that you're learning in this booklet. We operate through a scale, and the scale is the source of all correct sizes. Hence, inventing proportions on the spot is, in this instance, wrong.
        </p>
        <p>
          Last, it's worth mentioning viewport relative units, which are also tooling units that can come in handy. Setting a wrapper's width/height to a percentual value achieves one thing: it sets it to the *width of the parent*. Yes, the *width*. Browsers won't figure that when you say `height: 50%` you probably mean 50% of the height of the parent.
        </p>
        <p>
          In saying "the parent", you may be going for the viewport (a.k.a. the browser window) width. That's where viewport relative units come into action. You can use `50vw` for "50% of the viewport width", and that will yield a reliable 50% of the window width. For height, you can use `height: 50vh` to get 50% of the window height, and this is particularly useful for modals, or overlays that are sized in relation to the window size.
        </p>
        <p>
          I won't go into length here about that since there are specific tutorials on viewport relative units out there that also explain `vmin` and `vmax`. This is just so you're aware of them.
        </p>
      </article>
      <article>
        <p>
          You may be surprised when I say this, but you don't need a grid framework. Some of them are fine tools, but as a developer, the more you understand the problem domain, the more powerful you are, and this is a problem that is only hard if you never bothered doing that. This belief ultimately leads to you being constrained by nothing but your creativity, and never by your technical expertise. You're welcome to outsource this to a tool once you learn it. But I'm sure you won't want to.
        </p>
        <p>
          Every time someone suggests a field needs to be nudged to a direction by one pixel, it's almost a given they're doing eyeball-oriented design. That won't get you far. It also makes the discussion a lot more complicated. Suddenly it's up for debate things that, in reality, are either in the correct place or not at all.
        </p>
        <p>
          A grid has **units**. Things should fit nicely inside these units, including text. When upsizing a font, you upsize it with a scale, so your options are simple: you can move the font size up or down the scale (similarly to dragging the size number bars in Gridlovr), and the scale, which we will implement with a SASS function, will output a pixel value. In short, there'll be font size 0, 1, 2, 3, or X until it's too large, but you won't ever again pick a font size that just "looks right" by trial and error.
        </p>
        <p>
          Similarly, block elements that have fixed, or maximum/minimum, dimensions will be sized by a `units()` function. So instead of setting a fixed number of, say, pixels to a container, it'll be like this:
        </p>
        <pre><code>    .a-container {
      max-width: units(6);
    }</code></pre>
      </article>
      <article>
        <p>
          A text node's height is not determined by the `font-size` directive per se. That will be taken into consideration, but it's in fact the `line-height` that will. Sure, you **can** set the `height` if you also declare the node is a block node via `display: inline-block` and then that will be its height, but it'll make for some tall text nodes that are just weird. CSS is flexible and it'll let you do stupid things. That in fact is one of the main problems with it. It's up to you to make sure that flexibility is put to good use.
        </p>
        <p>
          See this:
        </p>
        <pre><code>    p {
      font-size: 16px;
      line-height: 1.5;
      margin-top: 16px;
    }</code></pre>
        <p>
          If you inspect the paragraph using your browser's developer tools, you'll see that the node is 24 pixels tall. If this paragraph were two lines long, it'd be 48 pixels tall. That's because by setting `line-height: 1.5` you declared that the line height should be 150% of the `font-size` value.
        </p>
        <p>
          There's nothing technically incorrect in styling things like this, by the way, if the grid unit size is in fact `24px`. But what comes with setting things like `line-height` using per-selector proportional measures such as the unitless number above is people end up setting it to something that may look ok but is incorrect as far as the grid goes. And then another paragraph elsewhere gets a `line-height: 1.3` directive, because it "looks ok". And soon enough the design is full of holes.
        </p>
        <p>
          Text is always positioned in the centre of the line. So if you want to vertically align a text node, simply give its line height the same height of the container:
        </p>
        <pre><code>    .cube {
      height: 320px;
      width: 320px;

      .promo-paragraph {
        line-height: 320px;
        font-size: 16px;
      }
    }</code></pre>
        <p>
          That wasn't so hard, was it?
        </p>
      </article>
      <article>
        <p>
          Now armed with this knowledge, we can establish a few ground rules:
        </p>
        <ul>
          <li>
            The base `line-height` value is 1 unit, whatever we decide the unit size should
be.
          </li>
          <li>
            Text can obviously be bigger than 1 unit, but in which case it'll take more than
one line to accomodate it.
          </li>
          <li>
            The dimensions of blocks (or anything that's not text) will always be X units
for height and width.
          </li>
          <li>
            Padding and margin values will also be specified in units.
          </li>
        </ul>
        <p>
          (This doesn't mean you'll need to go around setting the height of everything, to be clear. If a section has text inside and it needs to grow as tall as necessary to accomodate all text, that'll happen naturally as you add text that's correctly sized to it)
        </p>
        <p>
          What I'm describing here is the same approach explained in [Gridlover]. Gridlover is a nice tool for generating a scale which you can copy and paste into your styles. If you're not familiar, I suggest you go play with it and fiddle with the values a little. This will help clarifying the concepts explained thus far.
        </p>
        <p>
          Let's start by setting the base font size:
      </article>
    </section>
  </body>
</html>
